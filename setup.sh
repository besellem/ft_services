# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    setup.sh                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: besellem <besellem@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2021/04/05 10:17:55 by besellem          #+#    #+#              #
#    Updated: 2021/04/21 17:07:43 by besellem         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #


# Ansi color codes
BLACK="\033[0;30m"
RED="\033[0;31m"
GREEN="\033[0;32m"
YELLOW="\033[0;33m"
BLUE="\033[0;34m"
PURPLE="\033[0;35m"
CYAN="\033[0;36m"
GRAY="\033[0;37m"
B_BLACK="\033[1;30m"
B_RED="\033[1;31m"
B_GREEN="\033[1;32m"
B_YELLOW="\033[1;33m"
B_BLUE="\033[1;34m"
B_PURPLE="\033[1;35m"
B_CYAN="\033[1;36m"
B_GRAY="\033[1;37m"
CLR_COLOR="\033[0m"
CLR_LINE="\033[2K\r"
CLR_SCREEN="\033[2J\033[H"


# header generated by figlet command
echo "$CLR_SCREEN$B_RED\
 / _| |_     ___  ___ _ ____   _(_)
| |_| __|   / __|/ _ \ '__\ \ / / |/ __/ _ \/ __|
|  _| |_    \__ \  __/ |   \ V /| | (_|  __/\__ \\
|_|  \__|___|___/\___|_|    \_/ |_|\___\___||___/
       |_____|$CLR_COLOR\n
ðŸ–¥  - $B_YELLOW"$(uname)$CLR_COLOR "\n"



### whitout this cmd, minikube can't found images built locally
eval $(minikube docker-env)


# Install minikube command
install_minikube_cmd() {
	if [ `uname` = Darwin ]
	then
		
		# Check if minikube does not exist
		if [ ! -x `command -v minikube` ]
		then
			# check if brew does not exist
			if [ ! -x `command -v brew` ]
			then
				echo "Installing Homebrew..."
				/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"
			fi
		fi

		# if $MINIKUBE_HOME does not exist in .zshrc, add it
		if [ -z $MINIKUBE_HOME ]
		then
			grep MINIKUBE_HOME $HOME/.zshrc > /dev/null
			if [ $? -eq 1 ]
			then
				echo "export MINIKUBE_HOME=/goinfre/\$USER/" >> $HOME/.zshrc
			fi
		fi
	elif [ `uname` = Linux ]
	then
		if [ ! -x `command -v minikube` ]
		then
			echo "'minikube' is not installed in your system"
		fi
	else
		echo "You're not on a good system padawan"
	fi
}


start() {
	
	install_minikube_cmd

	# Launching minikube
	if [ `uname` = Darwin ]
	then
		minikube start --vm-driver=virtualbox --memory=2g --cpus=2 --extra-config=apiserver.service-node-port-range=1-35000
	elif [ `uname` = Linux ]
	then
		minikube start --driver=docker --extra-config=apiserver.service-node-port-range=1-35000
	fi

	minikube addons enable dashboard
	# minikube addons enable ingress
	minikube addons enable metrics-server
	minikube addons enable metallb

	## install metallb
	# On first install only
	# kubectl create secret generic -n metallb-system memberlist --from-literal=secretkey="$(openssl rand -base64 128)"
	# kubectl expose rc example --port=8765 --target-port=9376 --name=example-service --type=LoadBalancer
	# kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.9.6/manifests/namespace.yaml
	# kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.9.6/manifests/metallb.yaml
	# kubectl create secret generic -n metallb-system memberlist --from-literal=secretkey="$(openssl rand -base64 128)"
}


setup() {

	# whitout this cmd, minikube can't found images built locally
	# eval $(minikube docker-env)

	SVC_IP=$(minikube ip)
	
	# for contnr in 'nginx'
	# do
	# 	echo "# Building $B_RED$contnr...$CLR_COLOR"
	# 	docker build -t svc_$contnr ./srcs/$contnr
	# 	echo
	# done

	echo "# Building" $B_RED " images..." $CLR_COLOR

	# Build images
	docker build -t svc_nginx ./srcs/nginx
	docker build -t svc_wordpress ./srcs/wordpress --build-arg SERVICE_IP=$SVC_IP
	docker build -t svc_phpmyadmin ./srcs/phpmyadmin

	# Main yaml file
	kubectl apply -f ./srcs/configmap.yaml

	# All services
	kubectl apply -f ./srcs/nginx/nginx.yaml
	kubectl apply -f ./srcs/wordpress/wordpress.yaml
	kubectl apply -f ./srcs/phpmyadmin/phpmyadmin.yaml
	
	# kubectl apply -f ./srcs/ftps/ftps.yaml
	# kubectl apply -f ./srcs/grafana/grafana.yaml
	# kubectl apply -f ./srcs/influxdb/influxdb.yaml
	# kubectl apply -f ./srcs/mysql/mysql.yaml

	# open nginx welcome page in browser
	open http://$SVC_IP:80
}


# If no arg, or first arg equals "start" or "restart":
# Start / Restart script
if [ $# -lt 1 ] || [ $1 = "start" ]
then
	start
elif [ $1 = "delete" ] || [ $1 = "stop" ]
then
	# Delete minikube instances if minikube is running & exist
	minikube ip > /dev/null 2>&1
	if [ $? -eq 0 ] && [ -x `command -v minikube` ]
	then
		echo "Clearing docker images..."
		docker rmi --force svc_nginx svc_ftps svc_grafana svc_influxdb svc_mysql svc_phpmyadmin svc_wordpress alpine 2>/dev/null
		minikube delete
	else
		echo "Nothing to delete ðŸ¤˜"
	fi
elif [ $1 = "services" ]
then

	# check if minikube is running & exist
	minikube ip > /dev/null 2>&1
	if [ $? -ne 0 ]
	then
		start
	fi
	
	# Launch services
	setup
elif [ $1 = "install" ]
then
	# Install minikube
	install_minikube_cmd
fi

# Set env variable when exiting
zsh
